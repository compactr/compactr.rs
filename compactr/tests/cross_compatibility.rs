//! Cross-compatibility tests with compactr.js
//!
//! These tests validate binary format compatibility by loading fixture files
//! generated by the JavaScript implementation.
//!
//! ## Setup
//!
//! 1. Install compactr.js: `npm install`
//! 2. Generate fixtures: `node tests/fixtures/generate_fixtures.js`
//! 3. Run tests: `cargo test --test cross_compatibility`
//!
//! Or run the setup script: `./scripts/setup-fixtures.sh`

use compactr::{Decoder, Encoder, Property, SchemaType, Value};
use indexmap::IndexMap;
use std::path::Path;

/// Load a binary fixture file if it exists
fn load_fixture(name: &str) -> Option<Vec<u8>> {
    let path = Path::new("tests/fixtures").join(format!("{name}.bin"));
    std::fs::read(path).ok()
}

/// Check if fixtures are available
fn fixtures_available() -> bool {
    Path::new("tests/fixtures/manifest.json").exists()
}

/// Print helpful message if fixtures are missing
fn check_fixtures_or_skip() {
    if !fixtures_available() {
        println!("\n⚠️  JavaScript fixtures not found!");
        println!("   Run: ./scripts/setup-fixtures.sh");
        println!("   Or:  npm install && node tests/fixtures/generate_fixtures.js\n");
    }
}

/// Test that fixtures are available (runs first)
#[test]
fn test_00_fixtures_available() {
    check_fixtures_or_skip();
    if !fixtures_available() {
        panic!("JavaScript fixtures not generated. Run: ./scripts/setup-fixtures.sh");
    }
}

/// Test boolean encoding matches JS
#[test]
fn test_boolean_compatibility() {
    // Fixtures use {value: boolean} format
    let mut properties = IndexMap::new();
    properties.insert(
        "value".to_owned(),
        Property::required(SchemaType::boolean()),
    );
    let schema = SchemaType::object(properties);

    // Test true
    let mut obj = IndexMap::new();
    obj.insert("value".to_owned(), Value::Boolean(true));
    let mut encoder = Encoder::new();
    encoder.encode(&Value::Object(obj), &schema).unwrap();
    let rust_bytes = encoder.finish();

    if let Some(js_bytes) = load_fixture("boolean_true") {
        assert_eq!(
            rust_bytes.as_ref(),
            js_bytes.as_slice(),
            "Rust and JS encoding differ for boolean true"
        );
    } else {
        println!("⚠️  Skipping JS comparison (fixture not found)");
    }

    // Test false
    let mut obj = IndexMap::new();
    obj.insert("value".to_owned(), Value::Boolean(false));
    let mut encoder = Encoder::new();
    encoder.encode(&Value::Object(obj), &schema).unwrap();
    let rust_bytes = encoder.finish();

    if let Some(js_bytes) = load_fixture("boolean_false") {
        assert_eq!(
            rust_bytes.as_ref(),
            js_bytes.as_slice(),
            "Rust and JS encoding differ for boolean false"
        );
    }
}

/// Test integer encoding matches JS
#[test]
fn test_integer_compatibility() {
    // Fixtures use {value: int32} format
    let mut properties = IndexMap::new();
    properties.insert("value".to_owned(), Property::required(SchemaType::int32()));
    let schema = SchemaType::object(properties);

    // Test 42
    let mut obj = IndexMap::new();
    obj.insert("value".to_owned(), Value::Integer(42));
    let mut encoder = Encoder::new();
    encoder.encode(&Value::Object(obj), &schema).unwrap();
    let rust_bytes = encoder.finish();

    if let Some(js_bytes) = load_fixture("int32_42") {
        assert_eq!(
            rust_bytes.as_ref(),
            js_bytes.as_slice(),
            "Rust and JS encoding differ for int32"
        );
    }

    // Test i64
    let mut properties = IndexMap::new();
    properties.insert("value".to_owned(), Property::required(SchemaType::int64()));
    let schema = SchemaType::object(properties);

    let mut obj = IndexMap::new();
    obj.insert("value".to_owned(), Value::Integer(9_007_199_254_740_991)); // Max safe JS integer
    let mut encoder = Encoder::new();
    encoder.encode(&Value::Object(obj), &schema).unwrap();
    let rust_bytes = encoder.finish();

    if let Some(js_bytes) = load_fixture("int64_max_safe") {
        assert_eq!(rust_bytes.as_ref(), js_bytes.as_slice());
    }
}

/// Test string encoding matches JS
#[test]
fn test_string_compatibility() {
    // Fixtures use {value: string} format
    let mut properties = IndexMap::new();
    properties.insert("value".to_owned(), Property::required(SchemaType::string()));
    let schema = SchemaType::object(properties);

    // Test "Hello"
    let mut obj = IndexMap::new();
    obj.insert("value".to_owned(), Value::String("Hello".to_owned()));
    let mut encoder = Encoder::new();
    encoder.encode(&Value::Object(obj), &schema).unwrap();
    let rust_bytes = encoder.finish();

    if let Some(js_bytes) = load_fixture("string_hello") {
        assert_eq!(
            rust_bytes.as_ref(),
            js_bytes.as_slice(),
            "Rust and JS encoding differ for string"
        );
    }

    // Test empty string
    let mut obj = IndexMap::new();
    obj.insert("value".to_owned(), Value::String("".to_owned()));
    let mut encoder = Encoder::new();
    encoder.encode(&Value::Object(obj), &schema).unwrap();
    let rust_bytes = encoder.finish();

    if let Some(js_bytes) = load_fixture("string_empty") {
        assert_eq!(rust_bytes.as_ref(), js_bytes.as_slice());
    }
}

/// Test UUID encoding matches JS
#[test]
fn test_uuid_compatibility() {
    use uuid::Uuid;

    // Fixtures use {value: uuid} format
    let mut properties = IndexMap::new();
    properties.insert(
        "value".to_owned(),
        Property::required(SchemaType::string_uuid()),
    );
    let schema = SchemaType::object(properties);

    let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
    let mut obj = IndexMap::new();
    obj.insert("value".to_owned(), Value::Uuid(uuid));

    let mut encoder = Encoder::new();
    encoder.encode(&Value::Object(obj), &schema).unwrap();
    let rust_bytes = encoder.finish();

    if let Some(js_bytes) = load_fixture("uuid_standard") {
        assert_eq!(
            rust_bytes.as_ref(),
            js_bytes.as_slice(),
            "Rust and JS encoding differ for UUID"
        );
    }
}

/// Test IPv4 encoding matches JS
#[test]
fn test_ipv4_compatibility() {
    use std::net::Ipv4Addr;

    // Fixtures use {value: ipv4} format
    let mut properties = IndexMap::new();
    properties.insert(
        "value".to_owned(),
        Property::required(SchemaType::string_ipv4()),
    );
    let schema = SchemaType::object(properties);

    let ip = Ipv4Addr::new(192, 168, 1, 1);
    let mut obj = IndexMap::new();
    obj.insert("value".to_owned(), Value::Ipv4(ip));

    let mut encoder = Encoder::new();
    encoder.encode(&Value::Object(obj), &schema).unwrap();
    let rust_bytes = encoder.finish();

    if let Some(js_bytes) = load_fixture("ipv4_192_168_1_1") {
        assert_eq!(
            rust_bytes.as_ref(),
            js_bytes.as_slice(),
            "Rust and JS encoding differ for IPv4"
        );
    }
}

/// Test array encoding matches JS
#[test]
fn test_array_compatibility() {
    // Fixtures use {value: array} format
    let mut properties = IndexMap::new();
    properties.insert(
        "value".to_owned(),
        Property::required(SchemaType::array(SchemaType::int32())),
    );
    let schema = SchemaType::object(properties);

    // Test [1, 2, 3]
    let mut obj = IndexMap::new();
    obj.insert(
        "value".to_owned(),
        Value::Array(vec![
            Value::Integer(1),
            Value::Integer(2),
            Value::Integer(3),
        ]),
    );

    let mut encoder = Encoder::new();
    encoder.encode(&Value::Object(obj), &schema).unwrap();
    let rust_bytes = encoder.finish();

    if let Some(js_bytes) = load_fixture("array_int32_1_2_3") {
        assert_eq!(
            rust_bytes.as_ref(),
            js_bytes.as_slice(),
            "Rust and JS encoding differ for array"
        );
    }

    // Test empty array
    let mut obj = IndexMap::new();
    obj.insert("value".to_owned(), Value::Array(vec![]));

    let mut encoder = Encoder::new();
    encoder.encode(&Value::Object(obj), &schema).unwrap();
    let rust_bytes = encoder.finish();

    if let Some(js_bytes) = load_fixture("array_empty") {
        assert_eq!(rust_bytes.as_ref(), js_bytes.as_slice());
    }
}

/// Test object encoding matches JS (property order matters!)
#[test]
fn test_object_compatibility() {
    let mut properties = IndexMap::new();
    properties.insert("x".to_owned(), Property::required(SchemaType::int32()));
    properties.insert("y".to_owned(), Property::required(SchemaType::int32()));
    let schema = SchemaType::object(properties);

    let mut obj = IndexMap::new();
    obj.insert("x".to_owned(), Value::Integer(10));
    obj.insert("y".to_owned(), Value::Integer(20));

    let mut encoder = Encoder::new();
    encoder.encode(&Value::Object(obj), &schema).unwrap();
    let rust_bytes = encoder.finish();

    // Compactr.js 3.x interleaved format
    // [num_props, index0, size0, value0, index1, size1, value1, ...]
    assert_eq!(
        rust_bytes.as_ref(),
        &[
            2, // 2 properties
            0, 4, // property 0 (x), size 4
            0, 0, 0, 10, // x = 10 (big-endian)
            1, 4, // property 1 (y), size 4
            0, 0, 0, 20 // y = 20 (big-endian)
        ]
    );

    if let Some(js_bytes) = load_fixture("object_x_y") {
        assert_eq!(
            rust_bytes.as_ref(),
            js_bytes.as_slice(),
            "Rust and JS encoding differ for object"
        );
    }
}

/// Test complex user object matches JS
#[test]
fn test_user_object_compatibility() {
    use chrono::{TimeZone, Utc};
    use uuid::Uuid;

    let mut properties = IndexMap::new();
    properties.insert(
        "id".to_owned(),
        Property::required(SchemaType::string_uuid()),
    );
    properties.insert("name".to_owned(), Property::required(SchemaType::string()));
    properties.insert("email".to_owned(), Property::required(SchemaType::string()));
    properties.insert("age".to_owned(), Property::required(SchemaType::int32()));
    properties.insert(
        "created_at".to_owned(),
        Property::required(SchemaType::string_datetime()),
    );
    let schema = SchemaType::object(properties);

    let mut obj = IndexMap::new();
    obj.insert(
        "id".to_owned(),
        Value::Uuid(Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap()),
    );
    obj.insert("name".to_owned(), Value::String("Alice Johnson".to_owned()));
    obj.insert(
        "email".to_owned(),
        Value::String("alice@example.com".to_owned()),
    );
    obj.insert("age".to_owned(), Value::Integer(28));
    obj.insert(
        "created_at".to_owned(),
        Value::DateTime(Utc.timestamp_millis_opt(1_705_314_600_000).unwrap()), // 2024-01-15T10:30:00Z
    );

    let mut encoder = Encoder::new();
    encoder.encode(&Value::Object(obj), &schema).unwrap();
    let rust_bytes = encoder.finish();

    // Verify structure
    let mut buf = rust_bytes.as_ref();
    let decoded = Decoder::decode(&mut buf, &schema).unwrap();

    if let Value::Object(decoded_obj) = decoded {
        assert_eq!(
            decoded_obj.get("name"),
            Some(&Value::String("Alice Johnson".to_owned()))
        );
        assert_eq!(decoded_obj.get("age"), Some(&Value::Integer(28)));
    } else {
        panic!("Expected object");
    }

    // If fixture exists from JS, compare
    if let Some(js_bytes) = load_fixture("user_complete") {
        assert_eq!(
            rust_bytes.as_ref(),
            js_bytes.as_slice(),
            "Rust and JS encoding differ for complete user object.\n\
             This could indicate:\n\
             1. Different property order (schema order matters!)\n\
             2. Different DateTime encoding\n\
             3. Different UUID byte order\n\
             4. Different string encoding"
        );
    }
}

/// Test that decoding JS-generated binary works
#[test]
fn test_decode_js_fixture() {
    // Try to load and decode a JS-generated fixture
    if let Some(js_bytes) = load_fixture("simple_object") {
        // Schema must match what JS used
        let mut properties = IndexMap::new();
        properties.insert("value".to_owned(), Property::required(SchemaType::int32()));
        let schema = SchemaType::object(properties);

        let mut buf = js_bytes.as_slice();
        let result = Decoder::decode(&mut buf, &schema);

        assert!(
            result.is_ok(),
            "Failed to decode JS-generated fixture: {:?}",
            result.err()
        );
    }
}

/// Test all fixtures from manifest
#[test]
fn test_validate_all_fixtures() {
    use serde_json::Value as JsonValue;

    if !fixtures_available() {
        println!("⚠️  Fixtures not available, skipping comprehensive validation");
        return;
    }

    let manifest_path = Path::new("tests/fixtures/manifest.json");
    let manifest_data =
        std::fs::read_to_string(manifest_path).expect("Failed to read manifest.json");
    let manifest: JsonValue =
        serde_json::from_str(&manifest_data).expect("Failed to parse manifest.json");

    let fixtures = manifest["fixtures"]
        .as_array()
        .expect("manifest.fixtures should be array");

    println!("\n=== Validating {} fixtures ===\n", fixtures.len());

    let mut passed = 0;
    let mut failed = 0;

    for fixture in fixtures {
        let name = fixture["name"].as_str().unwrap();
        let filename = fixture["filename"].as_str().unwrap();
        let expected_size = fixture["size"].as_u64().unwrap() as usize;

        if let Some(data) = load_fixture(name) {
            if data.len() == expected_size {
                println!("✓ {}", filename);
                passed += 1;
            } else {
                println!(
                    "✗ {} (expected {} bytes, got {})",
                    filename,
                    expected_size,
                    data.len()
                );
                failed += 1;
            }
        } else {
            println!("⚠️  {} (not found)", filename);
            failed += 1;
        }
    }

    println!("\n=== Summary: {} passed, {} failed ===\n", passed, failed);

    assert_eq!(
        failed, 0,
        "Some fixtures failed validation (see output above)"
    );
}

/// Generate a README for cross-testing
#[test]
#[ignore] // Only run when generating documentation
fn generate_cross_test_readme() {
    let readme = r#"# Cross-Compatibility Testing

This directory contains tests and fixtures for validating binary format
compatibility between compactr.rs and compactr.js.

## Quick Start

### 1. Generate JS Test Vectors

```bash
cd tests/fixtures
npm install compactr
node generate_test_vectors.js
```

This creates `.bin` files with encoded data from JavaScript.

### 2. Run Rust Tests

```bash
cargo test --test cross_compatibility
```

Tests will automatically compare Rust-encoded data with JS fixtures.

## Manual Cross-Validation

### Encode in JavaScript, Decode in Rust

**JavaScript:**
```javascript
const { schema } = require('compactr');
const fs = require('fs');

const userSchema = schema({
  type: 'object',
  properties: {
    id: { type: 'integer', format: 'int32' },
    name: { type: 'string' }
  }
});

const buffer = userSchema.write({ id: 1, name: 'Alice' });
fs.writeFileSync('user.bin', buffer);
```

**Rust:**
```rust
use compactr::{Decoder, SchemaType, Property};
use indexmap::IndexMap;

let mut properties = IndexMap::new();
properties.insert("id".to_owned(), Property::required(SchemaType::int32()));
properties.insert("name".to_owned(), Property::required(SchemaType::string()));
let schema = SchemaType::object(properties);

let bytes = std::fs::read("user.bin")?;
let mut buf = bytes.as_slice();
let value = Decoder::decode(&mut buf, &schema)?;
println!("{:?}", value);
```

### Encode in Rust, Decode in JavaScript

**Rust:**
```rust
use compactr::{Encoder, SchemaType, Value, Property};

// ... setup schema ...
let mut obj = IndexMap::new();
obj.insert("id".to_owned(), Value::Integer(1));
obj.insert("name".to_owned(), Value::String("Alice".to_owned()));

let mut encoder = Encoder::new();
encoder.encode(&Value::Object(obj), &schema)?;
std::fs::write("user.bin", encoder.finish())?;
```

**JavaScript:**
```javascript
const { schema } = require('compactr');
const fs = require('fs');

const userSchema = schema({ /* ... */ });
const buffer = fs.readFileSync('user.bin');
const user = userSchema.read(buffer);
console.log(user);
```

## Common Issues

### Property Order Mismatch

Objects encode properties in **schema definition order**, not value order:

```javascript
// Schema defines order: x, then y
{ properties: { x: {}, y: {} } }

// Binary will ALWAYS be: x value, y value
// Regardless of object key order
```

### DateTime Precision

Both implementations use milliseconds since Unix epoch (i64).

### UUID Format

UUIDs are encoded as 16 raw bytes, not string representation.

## Debugging

To see hex dump of binary data:

**Bash:**
```bash
hexdump -C user.bin
```

**Rust:**
```rust
println!("{:02x?}", bytes);
```

**JavaScript:**
```javascript
console.log(buffer.toString('hex'));
```
"#;

    std::fs::write("tests/fixtures/README.md", readme).unwrap();
    println!("Generated tests/fixtures/README.md");
}
